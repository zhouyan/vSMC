\chapter{Random number generating}
\label{chap:Random number generating}

The library has a comprehensive \rng system to facilitate implementation of
Monte Carlo algorithms.

\section{Seeding}
\label{sec:Seeding}

The singleton class template \cppinline{SeedGenerator} can be used to generate
distinctive seed sequentially. For example,
\begin{cppcode}
  auto &seed = SeedGenerator<void, unsigned>::instance();
  RNG rng1(seed.get()); // Construct rng1
  RNG rng2(seed.get()); // Construct rng2 with another seed
\end{cppcode}
The first argument to the template can be any type. For different types,
different instances of \cppinline{SeedGenerator} will be created. Thus, the
seeds generated by \cppinline{SeedGenerator<T1>} and
\cppinline{SeedGenerator<T2>} will be independent. The second parameter is the
type of the seed values. It can be an unsigned integer type. Classes such as
\cppinline{Particle<T>} will use the generator of the following type,
\begin{cppcode}
  using Seed = SeedGenerator<NullType, VSMC_SEED_RESULT_TYPE>;
\end{cppcode}
where \cppinline{VSMC_SEED_RESULT_TYPE} is a configuration macro which is
defined to \cppinline{unsigned} by default.

One can save and set the seed generator using standard \cpp streams. For
example
\begin{cppcode}
  std::ifstream seed_txt("seed.txt");
  if (seed_txt.good())
      seed_txt >> Seed::instance(); // Read seed from a file
  else
      Seed::instance().set(101);    // The default seed
  seed_txt.close();
  // The program
  std::ofstream seed_txt("seed.txt");
  seed_txt << Seed::instance();     // Write the seed to a file
  seed_txt.close();
\end{cppcode}
This way, if the simulation program need to be repeated multiple times, each
time is will use a different set of seeds.

A single seed generator is enough for a single computer program. However, it is
more difficult to ensure that each computing node has a distinctive set of
seeds in a distributed system. A simple solution is to use the
\cppinline{modulo} method of \cppinline{SeedGenerator}. For example,
\begin{cppcode}
  Seed::instance().modulo(n, r);
\end{cppcode}
where $n$ is the number of processes and $r$ is the rank of the current node.
After this call, all seeds generated will belong to the equivalent class $s
\equiv r\mod{n}$. Therefore, no two nodes will ever generate the same seeds.

\section{Counter-based \protect\rng}
\label{sec:Counter-based RNG}

The standard library provides a set of \rng classes. Unfortunately, none of
them are suitable for parallel computing without considerable efforts.

The development by \textcite{Salmon:2011um} made high performance parallel \rng
much more accessible than it was before. In the author's personal opinion, it
is the most significant development for parallel Monte Carlo algorithms in
recent memory. See the paper for more details. Here, it is sufficient to
mention that, the \rng introduced in the paper use a deterministic function
$f_k$, such that, for any sequence $\{c_i\}_{i>0}$, the sequence
$\{y_i\}_{i>0}$, $y_i = f_k(c_i)$, appears as random. In addition, for $k_1 \ne
k_2$, $f_{k_1}$ and $f_{k_2}$ will generate two sequences that appear
statistically independent. Compared to more conventional \rng{}s which use
recursions $y_i = f(y_{i - 1})$, these counter-based \rng{}s are much easier to
setup in a parallelized environment.

If $c$, the counter, is an unsigned integer with $b$ bits, and $k$, the key, is
an unsigned integer with $d$ bits. Then for each $k$, the \rng has a period
$2^b$. And there can be at most $2^d$ independent streams.
Table~\ref{tab:Counter-based RNG} lists all counter-based \rng{}s implemented
in this library, along with the bits of the counter and the key. They all
conform to the \cppoo uniform \rng concept. All \rng{}s in
\textcite{Salmon:2011um} are implemented along with a few additions. Note that,
the actual period of an \rng can be longer. For example, \cppinline{Philox4x64}
has a 256-bits counter but output 64-bits integers. And thus it has a
$2^{1024}$ period. Such period length may seems very small compared to many
well known \rng{}s. For example, the famous Mersenne-Twister generator
(\cppinline{std::mt19937}) has a period $2^{19937} - 1$. However, combined with
$2^{256}$ independent streams, only the most demanding programs will find these
counter-base \rng{}s insufficient.

\begin{table}[t]
  \def\B{\textcolor{MRed}{\textit{B}}}
  \def\V{\textcolor{MRed}{\textit{V}}}
  \begin{tabu}{X[2l]X[2l]X[l]X[l]}
    \toprule
    & & \multicolumn{2}{c}{Bits} \\
    \cmidrule{3-4}
    Class & Result type & Counter & Key \\
    \midrule
    \texttt{AES128\_\B x32} & \texttt{std::uint32\_t} & $128$ & $128$ \\
    \texttt{AES128\_\B x64} & \texttt{std::uint64\_t} & $128$ & $128$ \\
    \texttt{AES192\_\B x32} & \texttt{std::uint32\_t} & $128$ & $192$ \\
    \texttt{AES192\_\B x64} & \texttt{std::uint64\_t} & $128$ & $192$ \\
    \texttt{AES256\_\B x32} & \texttt{std::uint32\_t} & $128$ & $256$ \\
    \texttt{AES256\_\B x64} & \texttt{std::uint64\_t} & $128$ & $256$ \\
    \texttt{ARS\_\B x32}    & \texttt{std::uint32\_t} & $128$ & $128$ \\
    \texttt{ARS\_\B x64}    & \texttt{std::uint64\_t} & $128$ & $128$ \\
    \texttt{Philox2x32\V}   & \texttt{std::uint32\_t} & $64$  & $64$  \\
    \texttt{Philox2x64\V}   & \texttt{std::uint64\_t} & $128$ & $128$ \\
    \texttt{Philox4x32\V}   & \texttt{std::uint32\_t} & $128$ & $128$ \\
    \texttt{Philox4x64\V}   & \texttt{std::uint64\_t} & $256$ & $256$ \\
    \texttt{Threefry2x32\V} & \texttt{std::uint32\_t} & $64$  & $64$  \\
    \texttt{Threefry2x64\V} & \texttt{std::uint64\_t} & $128$ & $128$ \\
    \texttt{Threefry4x32\V} & \texttt{std::uint32\_t} & $128$ & $128$ \\
    \texttt{Threefry4x64\V} & \texttt{std::uint64\_t} & $256$ & $256$ \\
    \bottomrule
  \end{tabu}
  \caption{Counter-based \rng; \B: either \cppinline{1}, \cppinline{2},
    \cppinline{4}, or \cppinline{8}; \V: either empty, \cppinline{SSE2}, or
    \cppinline{AVX2}.}
  \label{tab:Counter-based RNG}
\end{table}

\begin{table}[t]
  \begin{tabu}{X[l]X[l]}
    \toprule
    Macro & Default \\
    \midrule
    \texttt{VSMC\_RNG\_AES\_BLOCKS} & \texttt{4} \\
    \texttt{VSMC\_RNG\_ARS\_ROUNDS} & \texttt{5} \\
    \texttt{VSMC\_RNG\_ARS\_BLOCKS} & \texttt{4} \\
    \texttt{VSMC\_RNG\_PHILOX\_ROUNDS} & \texttt{10} \\
    \texttt{VSMC\_RNG\_PHILOX\_VECTOR\_LENGTH} & \texttt{4} \\
    \texttt{VSMC\_RNG\_THREEFRY\_ROUNDS} & \texttt{20} \\
    \texttt{VSMC\_RNG\_THREEFRY\_VECTOR\_LENGTH} & \texttt{4} \\
    \bottomrule
  \end{tabu}
  \caption{Configuration macros for counter-based \rng{}s}
  \label{tab:Configuration macros for counter-based RNGs}
\end{table}

\subsection{\protect\aesni intrinsics based \protect\rng}
\label{sub:AES-NI intrinsics based RNG}

The \aesni intrinsics based \rng{}s in \textcite{Salmon:2011um} are implemented
in a more general form,
\begin{cppcode}
  template <typename ResultType, typename KeySeqType, std::size_t Rounds,
  std::size_t Blocks>
  using AESNIEngine =
  CounterEngine<AESNIGenerator<ResultType, KeySeqType, Rounds, Blocks>>;
\end{cppcode}
where \cppinline{KeySeqType} is the class used to generate the sequence of
round keys; \cppinline{Rounds} is the number of rounds of \aes encryption to be
performed. See the reference manual for details of how to define the key
sequence class. The \aesni intrinsics have a latency of seven or eight cycles,
while they can be issued at every cycle. Therefore better performance can be
achieved if multiple 128-bits random integers are generated at the same time.
This is specified by the template parameter \cppinline{Blocks}. Larger blocks,
up to eight, can improve runtime performance but this is at the cost of larger
state size.

Four types of key sequences are implemented by the library, corresponding to
the \ars algorithm in \textcite{Salmon:2011um} and the \aes-128, \aes-192, and
\aes-256 algorithms. The following \rng engines are defined.
\begin{cppcode}
  template <typename ResultType, std::size_t Rounds = VSMC_RNG_ARS_ROUNDS,
      std::size_t Blocks = VSMC_RNG_ARS_BLOCKS>
  using ARSEngine =
      AESNIEngine<ResultType, ARSKeySeq<ResultType>, Rounds, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES128Engine =
      AESNIEngine<ResultType, AES128KeySeq<ResultType, 10>, 10, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES192Engine =
      AESNIEngine<ResultType, AES192KeySeq<ResultType, 12>, 12, Blocks>;

  template <typename ResultType, std::size_t Blocks = VSMC_RNG_AES_BLOCKS>
  using AES256Engine =
      AESNIEngine<ResultType, AES256KeySeq<ResultType, 14>, 14, Blocks>;
\end{cppcode}
The default template arguments can be changed by configuration macros listed in
table~\ref{tab:Configuration macros for counter-based RNGs}. Shortcuts are also
defined, as listed in table~\ref{tab:Counter-based RNG}. For example,
\cppinline{ARS_4x32} is \cppinline{ARSEngine} with result type
\cppinline{std::uint32_t}, four blocks, and the default number of rounds.

\subsection{Philox}
\label{sub:Philox}

The Philox algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename ResultType, std::size_t K = VSMC_RNG_PHILOX_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_PHILOX_ROUNDS>
  using PhiloxEngine = CounterEngine<PhiloxGenerator<ResultType, K, Rounds>>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Shortcuts are also defined, as listed in
table~\ref{tab:Counter-based RNG}. For example, \cppinline{Philox4x32} is
\cppinline{PhiloxEngine} with result type \cppinline{std::uint32_t}, vector
length four, and the default number of rounds.

\subsection{Threefry}
\label{sub:Threefry}

The Threefry algorithm in \textcite{Salmon:2011um} is implemented in a more
general form,
\begin{cppcode}
  template <typename ResultType, std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS>
  using ThreefryEngine = CounterEngine<ThreefryGenerator<ResultType, K, Rounds>>;
\end{cppcode}
The default vector length and the number of rounds can be changed by
configuration macros listed in table~\ref{tab:Configuration macros for
  counter-based RNGs}. Shortcuts are also defined, as listed in
table~\ref{tab:Counter-based RNG}. For example, \cppinline{Threefry4x32} is
\cppinline{ThreefryEngine} with result type \cppinline{std::uint32_t}, vector
length four, and the default number of rounds.

If \sse{}2 intrinsics are supported, then a more optimized version is also
implemented. This implementation can have higher performance at the cost of
larger state size. If \avx{}2 intrinsics are supported, then a even more
optimized, with even larger state size version is also implemented.
\begin{cppcode}
  template <typename ResultType, std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS>
  using ThreefryEngineSSE2 =
      CounterEngine<ThreefryGeneratorSSE2<ResultType, K, Rounds>>;

  template <typename ResultType, std::size_t K = VSMC_RNG_THREEFRY_VECTOR_LENGTH,
      std::size_t Rounds = VSMC_RNG_THREEFRY_ROUNDS>
  using ThreefryEngineAVX2 =
      CounterEngine<ThreefryGeneratorAVX2<ResultType, K, Rounds>>;
\end{cppcode}

\subsection{Default \protect\rng}
\label{sub:Default RNG}

Note that, not all \rng{}s defined by the library is available on all
platforms. The library also defines a type alias \cppinline{RNG} which is one
of the \rng{}s listed in table~\ref{tab:Counter-based RNG}. More specifically,
if the \aesni intrinsics are supported,
\begin{cppcode}
  using RNG = ARS_4x32;
\end{cppcode}
otherwise if \avx{}2 intrinsics are supported,
\begin{cppcode}
  using RNG = Threefry4x32AVX2;
\end{cppcode}
otherwise if \sse{}2 intrinsics are supported,
\begin{cppcode}
  using RNG = Threefry4x32SSE2;
\end{cppcode}
and last, on all other platforms,
\begin{cppcode}
  using RNG = Threefry4x32;
\end{cppcode}
This can be changed by the configuration macro \cppinline{VSMC_RNG_TYPE}.

\section{Non-deterministic \protect\rng}
\label{sec:Non-deterministic RNG}

If the \rdrand intrinsics are supported, the library also implement three
\rng{}s, \cppinline{RDRAND16}, \cppinline{RDRAND32} and \cppinline{RDRAND64}.
They output 16-, 32-, and 64-bits random unsigned integers, respectively.

\section{\protect\mkl{} \protect\rng}
\label{sec:MKL RNG}

The \mkl library provides some high performance \rng{}s. The library implement
a wrapper class \cppinline{MKLEngine} that makes them accessible as \cppoo{}
generators. They are listed in table~\ref{tab:MKL RNG}. Note that, \mkl{}
\rng{}s performs best when they are used to generate vectors of random numbers.
These wrappers use a buffer to store such vectors. And thus they have much
larger state space than usual \rng{}s.

\begin{table}[t]
  \begin{tabu}{X[l]X[l]}
    \toprule
    Class & \mkl \brng \\
    \midrule
    \texttt{MKL\_MCG59}         & \texttt{VSL\_BRNG\_MCG59}         \\
    \texttt{MKL\_MT19937}       & \texttt{VSL\_BRNG\_MT19937}       \\
    \texttt{MKL\_MT2203}        & \texttt{VSL\_BRNG\_MT2203}        \\
    \texttt{MKL\_SFMT19937}     & \texttt{VSL\_BRNG\_SFMT19937}     \\
    \texttt{MKL\_NONDETERM}     & \texttt{VSL\_BRNG\_NONDETERM}     \\
    \texttt{MKL\_ARS5}          & \texttt{VSL\_BRNG\_ARS5}          \\
    \texttt{MKL\_PHILOX4X32X10} & \texttt{VSL\_BRNG\_PHILOX4X32X10} \\
    \bottomrule
  \end{tabu}
  \caption[Intel \protect\mkl{} \protect\rng]{\mkl{} \rng. Note: all
    classes can have a suffix \cppinline{_64}.}
  \label{tab:MKL RNG}
\end{table}

\section{Multiple \protect\rng streams}
\label{sec:Multiple RNG streams}

Earlier in section~\ref{sub:Particle} we introduced that
\cppinline{particle.rng(i)} returns an independent \rng instance. This is
actually done through a class template called \cppinline{RNGSet}. Three of them
are implemented in the library. They all have the same interface,
\begin{cppcode}
  RNGSet<RNG> rng_set(N); // A set of N RNGs
  rng_set.resize(n);      // Change the size of the set
  rng_set.seed();         // Seed each RNG in the set with Seed::instance()
  rng_set[i];             // Get a reference to the i-th RNG
\end{cppcode}
The first implementation is \cppinline{RNGSetScalar}. As its name suggests, it
is only a wrapper of a single \rng. All calls to \cppinline{rng_set[i]} returns
a reference to the same \rng. It is only useful when an \cppinline{RNGSet}
interface is required while the thread-safety and other issues are not
important.

The second implementation is \cppinline{RNGSetVector}. It is an array of
\rng{}s with length $N$. It has memory cost $O(N)$. Many of the counter-based
\rng{}s have small state size and thus for moderate $N$, this cost is not an
issue. The method calls \cppinline{rng_set[i]} and \cppinline{rng_set[j]}
return independent \rng{}s if $i \ne j$.

Last, if \tbb is available, there is a third implementation
\cppinline{RNGSetTBB}, which uses thread-local storage (\tls). It has much
smaller memory footprint than \cppinline{RNGSetVector} while maintains better
thread-safety. The performance impact of using \tls is minimal unless the
computation at the calling site is trivial. For example,
\begin{cppcode}
  std::size_t eval_pre(SingleParticle<T> sp)
  {
      auto &rng = sp.rng();
      // using rng to initialize state
      // do some computation, likely far more costly than TLS
  }
\end{cppcode}
The type alias \cppinline{RNGSet} is defined to be \cppinline{RNGSetTBB} if
\tbb is available, otherwise defined to be \cppinline{RNGSetVector}. It is used
by the \cppinline{Particle} class template. One can replace the type of \rng
set used by \cppinline{Particle<T>} with a member type of \cppinline{T}.  For
example,
\begin{cppcode}
  class T
  {
      using rng_set_type = /* User defined type */;
  };
\end{cppcode}
will make the \rng set used by \cppinline{Particle<T>} replaced by the user
defined type.

\section{Distributions}
\label{sec:Distributions}

The library also provides implementations of some common distributions. They
all conforms to the \cppoo random number distribution concepts. Some of them
are the same as those in the \cppoo standard library, with
\cppinline{CamelCase} names. For example, \cppinline{NormalDistribuiton} can be
used as an drop-in replacement for \cppinline{std::normal_distribuiton}. This
includes all of the continuous distributions defined in the standard library.
Their benefits compared to the standard library will be discussed later.
Table~\ref{tab:Random number distributions} lists all the additional
distributions implemented.

\begin{table}[t]
  \begin{tabu}{X[l]X[4l]}
    \toprule
    Class & Notes \\
    \midrule
    \texttt{UniformBits} & No parameters,
    uniform on the set $\{0,\dots,2^b - 1\}$, where $b$ is the number of bits
    of the result type, which has to be an unsigned integer type. \\
    \texttt{U01}         & No parameters, uniform on $[0, 1)$ \\
    \texttt{U01CC}       & No parameters, uniform on $[0, 1]$ \\
    \texttt{U01CO}       & No parameters, uniform on $[0, 1)$ \\
    \texttt{U01OC}       & No parameters, uniform on $(0, 1]$ \\
    \texttt{U01OO}       & No parameters, uniform on $(0, 1)$ \\
    \texttt{Laplace}     & Parameters: location \texttt{a}; scale \texttt{b}\\
    \texttt{Levy}        & Parameters: location \texttt{a}; scale \texttt{b}\\
    \texttt{Pareto}      & Parameters: shape \texttt{a}; scale \texttt{b}   \\
    \texttt{Rayleigh}    & Parameters: scale \texttt{sigma}                 \\
    \bottomrule
  \end{tabu}
  \caption{Random number distributions. Note: all class names have a suffix
    \cppinline{Distribution} which is omitted in the table}
  \label{tab:Random number distributions}
\end{table}

The last, the library also implement the multivariate Normal distribution. Its
usable is summarized by the following.
\begin{cppcode*}{texcomments}
  double mean[2] = { /* the mean vector */ };
  double cov[4] = { /* the covariance matrix */ };
  double chol[3];
  double r[2];
  // Compute the lower triangular of the Cholesky decomposition
  cov_chol(2, cov, chol);
  RNG rng;
  NormalMVDistribution<double, 2> norm2(mean, chol); // Bivariate Normal
  NormalMVDistribution<double, Dynamic> normd(2, mean, chol); // Same as above
  norm2(rng, r); // Generate a bivariate Normal
  normd(rng, r); // Same as above
\end{cppcode*}
We shall mention here that the static form, where the dimension is specified as
a template parameter is more efficient.

\section{Vectorized random number generating}
\label{sec:Vectorized random number generating}

The \rng{}s and distributions implemented by this library provides vectorized
operations. For example,
\begin{cppcode}
  std::size_t n = 1000;
  RNG rng;
  NormalDistribution<double> norm(0, 1);
  Vector<RNG::result_type> u(n);
  Vector<double> r(n);
  rng(n, u.data());           // Generate n random unsigned integers
  rng_rand(rng, n, u.data()); // Same as above
  norm(rng, n, r.data());     // Generate n Normal random numbers
  normal_distribution(rng, n, r.data(), 0.0, 1.0);     // Same as above
  normal_distribution(rng, n, r.data(), norm.param()); // Same as above
  rng_rand(rng, norm, n, r.data());                    // Same as above
\end{cppcode}
Note that these functions will be specialized to use \mkl routines if
\cppinline{rng} is one of the engines listed in table~\ref{tab:MKL RNG}.
